alexb853@gmail.com
< your secret here >


Kernel System Calls
-------------------
The README program created a file named 'goodLuck' in the welcomeToDevopsJan22
directory that contains the massage 'There you go... tell me what I d'

Binary Numbers
--------------
1. 111 = (1*2^2) + (1*2^1) + (1*2^0) = 7
100 = (1*2^2) + (0*2^1) + (0*2^0) = 4
10110 = (1*2^4) + (0*2^3) + (1*2^2) + (1*2^1) + (0*2^0) = 22

2. The available decimal range represented by a 8 bits binary number is 2^8
   Which is 256 but we start to count from 0 so the range is 255.

3. A method that could represent a negative numbers between 0-255 Given a 9 bits binary number
   is to designate the leftmost bit as the sign bit.

   If the sign bit is 0, the number is positive.
   If the sign bit is 1, the number is negative.
   If the number is negative, take the one's complement of the remaining 8 bits.
   For example:
   Let's say we have the 9-bit binary number 110110011:
   The leftmost bit is 1, indicating that it's a negative number.
   To find the magnitude, take the one's complement of the remaining 8 bits:
   Invert all the bits (change 1s to 0s and 0s to 1s): 001001100.
   Now, convert the magnitude (001001100) to decimal: 36.

   Since the sign bit is 1, the overall value is -36.

4.A method that can represent a floating point numbers using a 8 bits binary numbers could be like the following:

Integer part (3 bits): Use the first 3 bits for the integer part.
This allows you to represent integers from 0 to 7.

Fractional part (5 bits): Use the remaining 5 bits for the fractional part. Since we want a precision of 0.1,
divide the fractional part by 0.1. This gives you a range of 0 to 9.999, which can be represented using 4 bits.
The remaining bit can be used for rounding.

For example:

Decimal number: 5.3
Integer part (3 bits): 5 (binary: 101)
Fractional part (5 bits): 3 / 0.1 = 30 (binary: 11110)
Combine them: 10111110


